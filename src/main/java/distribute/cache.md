# 1.分布式缓存

在后端系统中，由于数据库读写性能所限，性能瓶颈往往出现在数据库上，为了降低数据库访问压力，可以采取的方式有缓存、数据库读写分离、分表等。

其中，对于数据库读取压力过大的情况，缓存可以说是首选解决方式

缓存按照数据存储位置来区分，缓存可以分为两种: 进程内缓存与进程外缓存

- 进程内缓存: 最简单的可以直接用语言内的散列表(Java HashMap，Python字典 等)，或者一些功能更完善的第三方库

- 进程外缓存: 常见的如Redis，Memcache等
- 进程内缓存和Redis的区别

![image-20210912175734204](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210912175734204.png)

# 2.缓存预热

缓存预热就是系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。

缓存预热解决方案：直接写个缓存刷新页面，上线时手工操作下；数据量不大，可以在项目启动的时候自动进行加载；定时刷新缓存。

# 3.缓存淘汰

常用的缓存淘汰策略有以下

- 先进先出算法（FIFO）
- Least Frequently Used（LFU）
  淘汰一定时期内被访问次数最少的页面，以次数作为参考
- Least Recently Used（LRU）
  淘汰最长时间未被使用的页面，以时间作为参考

# 4.**缓存穿透**

所谓缓存穿透就是说在缓存中不存在，然后直接在数据库中查询的现象

- 一般来说，缓存穿透的场景发生在故意攻击的场景下；比如说，本来查询意见商品的序号是正数，但是请求方总是请求大量的负数过来，导致缓存无效，全部流量都打在了数据库中，如果某一时刻流量过大，则会导致数据库崩溃；
- 解决方案：布隆过滤器、缓存空值、
- ![img](https://pic3.zhimg.com/80/v2-cdca4cd9dd85914b2baf365398d055e6_720w.jpg)

# 5.缓存雪崩

所谓缓存雪崩就是在某一个时刻，缓存集大量失效。所有流量直接打到数据库上，对数据库造成巨大压力；

![img](https://pic3.zhimg.com/80/v2-8f55ef59fed22139fe8b1884c38eafe6_720w.jpg)

解决方案：保持缓存层的高可用性、限流降级组件、缓存不过期、优化缓存过期时间等



# 6.布隆过滤器（Bloom Filter）

直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：

- 首先需要k个hash函数，每个函数可以把key散列成为1个整数

- 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0

- 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1

- 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

![img](https://pic002.cnblogs.com/images/2012/274814/2012071317402283.png)

优点：不需要存储key，节省空间

缺点：

- 算法判断key在集合中时，有一定的概率key其实不在集合中

- 无法删除

典型的应用场景：
某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。
比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。

这是只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次
需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。



