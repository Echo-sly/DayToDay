## `在多线程下 Map的几大缺点`
#### 1.数据丢失（并发赋值时被覆盖）：在put的时候，因为该方法不是同步的，假如有两个线程A,B它们的put的key的hash值相同，不论是从头插入还是从尾插入，假如A获取了插入位置为x，但是还未插入，此时B也计算出待插入位置为x，则不论AB插入的先后顺序肯定有一个会丢失。
#### 2.已遍历空间内丢失元素[JDK7]：`tranfer()`数据迁移方法在数组非常大时会非常消耗资源，当线程迁移过程中，其他线程新增的元素有可能会落在已经遍历过的哈希槽上，在遍历完成以后，table数组引用指向了`newtable`，这时新增元素就会丢失，被无情的垃圾回收
#### 3.新表被覆盖：如果resize()完成，执行了`table=newtable`,则后续的元素就可以在新表上进行插入操作，但是如果有多个线程同时执行resize，每个线程又都会`new Entry[newCapacity]`,由于这时线程内的局部数组对象，线程之间是不可见的，因此在前一完成后，`resize`的线程会赋值给table线程共享变量，从而覆盖其他线程的操作，因此在“新表”中进行插入操作的对象会被无情地丢弃。
#### 4.死链问题：HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环
